{
  "version": 3,
  "sources": ["../src/typescript/index.ts", "../src/typescript/utils.ts", "../src/typescript/wait-elements.ts", "../src/typescript/append.ts", "../src/typescript/constants.ts", "../src/typescript/dialog.ts", "../src/typescript/tag-alert.ts", "../src/typescript/contact-divs.ts", "../src/typescript/search-box.ts", "../src/typescript/save-alert.ts", "../src/typescript/icons.ts"],
  "sourcesContent": ["import { addAddressButtons, addSectionToggle } from './append'\nimport { addTagElements, checkNewTagAlert, appendTagLink } from './tag-alert'\nimport { colorConsole, getAddressDivs } from './utils'\nimport { processContactDivs } from './contact-divs'\nimport * as wait from './wait-elements'\nimport * as constants from './constants'\nimport { addContactSearchBox } from './search-box'\nimport { attachSaveAlert } from './save-alert'\nimport { changeFontAwesomeIcons } from './icons'\n\nexport const appended: ProspectCue = {\n    addressDivs: {},\n    tagsAdded: [],\n    contactDivs: [],\n    contactDivTriggers: [],\n    searchBox: null,\n}\n\n// Initialize the scripts on page load/reload\nstartProspectCueCustomizations()\n\n// This only runs on page load/reload\nasync function startProspectCueCustomizations() {\n    colorConsole('Starting prospectcue customizations', 'green')\n    if (window.location.pathname.includes('/contacts/detail/')) {\n        await runContactPageCustomizations()\n    }\n    if (window.location.pathname.includes('conversations')) {\n        colorConsole(\n            'reloaded to conversations page, checking for add new tag',\n            'yellow'\n        )\n        await checkNewTagAlert()\n    }\n    if (window.location.pathname.includes('/opportunities/list')) {\n        colorConsole(\n            'reloaded to opportunities list page, checking for add new tag',\n            'yellow'\n        )\n        await checkNewTagAlert()\n    }\n\n    // watch for clicks on the window\n    window.addEventListener('click', handleWindowClicks)\n}\n\nexport async function runContactPageCustomizations() {\n    colorConsole('running contact page customizations', 'green')\n    try {\n        await processContactDivs()\n    } catch (e) {\n        colorConsole(`error processing contact divs`, 'red', e as Error)\n    }\n    try {\n        await addSectionToggle()\n    } catch (e) {\n        colorConsole(`error adding section toggle`, 'red', e as Error)\n    }\n    try {\n        // await addContactSearchBox();\n        await addAddressButtons()\n    } catch (e) {\n        colorConsole(`error adding address buttons`, 'red', e as Error)\n    }\n    try {\n        await addTagElements()\n    } catch (e) {\n        colorConsole(`error adding tag elements`, 'red', e as Error)\n    }\n    try {\n        await attachSaveAlert()\n    } catch (e) {\n        colorConsole(`error attaching save alert`, 'red', e as Error)\n    }\n}\n\nfunction findAncestorWithHref(\n    element: EventTarget | null\n): HTMLAnchorElement | null {\n    colorConsole(`finding ancestor with href`, 'yellow', element as EventTarget)\n    while (element) {\n        if (\n            element instanceof HTMLAnchorElement &&\n            element.hasAttribute('href')\n        ) {\n            return element\n        }\n        element = (element as HTMLElement).parentElement\n    }\n    return null\n}\n\nfunction handleWindowClicks(e: MouseEvent) {\n    const target = e.target as HTMLElement\n    const anchor = findAncestorWithHref(target)\n\n    const CONTACTS_PATH = '/contacts/detail/'\n    const CONVERSATIONS_PATH = '/conversations/conversations'\n    const OPPORTUNITIES_PATH = '/opportunities/list'\n\n    colorConsole(`click was on an anchor element: ${anchor?.href}`, 'yellow')\n    // set the current url at the time of the click\n    const currentPath = window.location.pathname\n    setTimeout(async () => {\n        const newPath = window.location.pathname\n        // dont run if link is an id selector on same page\n        if (currentPath === newPath && window.location.hash) {\n            return\n        }\n        // Contact Details Page\n        if (anchor?.href.includes(CONTACTS_PATH)) {\n            await runContactPageCustomizations()\n            colorConsole(\n                `click on contact page, checking for add new tag`,\n                'yellow'\n            )\n            // Conversations Page\n        } else if (window.location.pathname.includes(CONVERSATIONS_PATH)) {\n            colorConsole(\n                `click on conversations page, checking for add new tag`,\n                'yellow'\n            )\n            await checkNewTagAlert()\n\n            // Opportunities Page\n        } else if (\n            currentPath.includes(OPPORTUNITIES_PATH) &&\n            window.location.pathname.includes(OPPORTUNITIES_PATH)\n        ) {\n            colorConsole(\n                `click on opportunities page, checking for add new tag`,\n                'yellow'\n            )\n            await checkNewTagAlert()\n        }\n        colorConsole(`checking for pencil icons`, 'yellow')\n        await changeFontAwesomeIcons()\n    }, 500)\n}\n\nexport {\n    wait,\n    addTagElements,\n    appendTagLink,\n    checkNewTagAlert,\n    colorConsole,\n    startProspectCueCustomizations,\n    getAddressDivs,\n    addAddressButtons,\n    processContactDivs,\n    constants,\n    addContactSearchBox,\n    changeFontAwesomeIcons as updatePencilIcon,\n}\n", "import { appended } from './index';\n\n/**\n * cycles through the labels on the page and finds the address fields\n */\nexport function getAddressDivs(labels: NodeList) {\n    // Find the Street Address label, then find the containing Div, then use its siblings to find the other address fields.\n    let addressDivChildren;\n    for (let label of labels) {\n        if (\n            label.textContent &&\n            label.textContent.trim() === 'Street Address'\n        ) {\n            /** @type {HTMLElement} */\n            addressDivChildren = (label as HTMLElement).closest(\n                '.pt-3 > div'\n            )?.children;\n            if (!addressDivChildren) {\n                colorConsole('could not find addressDivChildren', 'red');\n                return;\n            }\n\n            const addressDivs: AddressDivs = {\n                streetLabel: label as HTMLElement,\n                streetDiv: addressDivChildren[1] as HTMLElement,\n                cityDiv: addressDivChildren[2] as HTMLElement,\n                stateDiv: addressDivChildren[4] as HTMLElement,\n                zipDiv: addressDivChildren[5] as HTMLElement,\n                addressDivChildren: addressDivChildren,\n            };\n\n            appended.addressDivs = addressDivs;\n            return addressDivs;\n        }\n    }\n}\n\nexport function colorConsole(\n    logString: string,\n    color?: 'red' | 'green' | 'blue' | 'yellow' | 'orange',\n    object?: object\n) {\n    const colorMap = {\n        red: '#f1889a',\n        green: '#6DECB9',\n        blue: '#88FFF7',\n        yellow: '#FFF6BF',\n        orange: '#f19684',\n    };\n\n    color ??= 'blue';\n\n    console.log(\n        `%c \uD83E\uDE90 ${logString}`,\n        `font-size: 13px; color: ${colorMap[color]} `,\n        object\n    );\n}\n", "import { colorConsole } from './utils'\n\ntype Props = {\n    selector: string\n    elementName?: string\n}\n\nexport function waitForElement(props: Props) {\n    const { elementName, selector } = props\n\n    elementName &&\n        colorConsole(`${elementName}...waiting for ${props.selector}`)\n    return new Promise(\n        (\n            resolve: (value: HTMLElement) => void,\n            reject: (error: Error) => void\n        ) => {\n            const element = document.querySelector(selector) as HTMLElement\n            if (element) {\n                resolve(element)\n                return\n            }\n            // if element is not found, wait for it to be added to the DOM\n            const observer = new MutationObserver((mutations) => {\n                mutations.forEach((mutation) => {\n                    const nodes = Array.from(mutation.addedNodes)\n                    nodes.forEach((node) => {\n                        if (node instanceof HTMLElement) {\n                            const element = node.querySelector(selector)\n                            if (node.matches(selector)) {\n                                colorConsole(\n                                    `${elementName}...found -> ${selector} in`,\n                                    'green',\n                                    node\n                                )\n                                observer.disconnect()\n                                resolve(node)\n                            }\n                        }\n                    })\n                })\n\n                setTimeout(() => {\n                    colorConsole(\n                        `${elementName}...${selector} not found after 4 seconds...`,\n                        'orange'\n                    )\n                    observer.disconnect()\n                    reject(\n                        new Error(\n                            `${elementName} was not found after 4 seconds`\n                        )\n                    ) // Reject the promise with a new Error\n                }, 4000)\n            })\n\n            observer.observe(document.body, {\n                childList: true,\n                subtree: true,\n            })\n        }\n    )\n}\n\n/**\n * Waits for a specified number of elements to be present in the DOM\n * * To wait for children, use the selector:\n * @example waitForManyELements(selectorAll: '.parent > *')\n * @param {string} selectorAll - the CSS Selector for the parent node\n * @param {number} numElements - the number of elements to wait for\n * @param {string} textContent - the textContent of the parent node\n * @returns {Promise<NodeList | Element>} - the NodeList of the parent's children\n */\nexport function waitForManyElements(\n    selectorAll: string,\n    numElements = 1,\n    textContent?: string,\n    elementName?: string\n) {\n    colorConsole(\n        `${elementName}: waiting for ${numElements} children on ${elementName} ${\n            textContent ? `with textContent ${textContent}` : ''\n        }`\n    )\n    return new Promise(\n        (\n            resolve: (value: NodeList) => void,\n            reject: (error: Error) => void\n        ) => {\n            const elements = document.querySelectorAll(selectorAll)\n            if (elements.length >= numElements) {\n                colorConsole(\n                    `${elementName} already has at least ${numElements} nodes...`,\n                    'green',\n                    elements\n                )\n                resolve(elements)\n            }\n\n            const observer = new MutationObserver((mutations) => {\n                colorConsole(\n                    `starting ${elementName} mutation observer...`,\n                    'yellow'\n                )\n                mutations.forEach((mutation) => {\n                    const elements = document.querySelectorAll(selectorAll)\n                    if (elements.length >= numElements) {\n                        colorConsole(\n                            `${elementName}: ${elementName} now has at least ${numElements} nodes...`,\n                            'green',\n                            elements\n                        )\n                        resolve(elements)\n                        observer.disconnect()\n                    }\n                })\n\n                setTimeout(() => {\n                    colorConsole(\n                        `${elementName}: ${elementName} still does not have ${numElements} nodes after 4 seconds...`,\n                        'orange'\n                    )\n                    observer.disconnect()\n                    reject(\n                        new Error(\n                            `${elementName} did not get ${numElements} nodes after 4 seconds`\n                        )\n                    ) // Reject the promise with a new Error\n                }, 4000)\n            })\n\n            observer.observe(document.body, {\n                childList: true,\n                subtree: true,\n            })\n        }\n    )\n}\n\n/**\n * Searches a NodeList and waits for specified textContent before resolving\n * @param {string} selectorAll - the CSS Selector for the parent node\n * @param {string} textContent - the textContent of the parent node\n * @returns {Promise<NodeList | Element>} - the NodeList of the parent's children\n *  */\nexport function waitForTextContent(\n    selectorAll: string,\n    textContent: string,\n    elementName?: string\n) {\n    return new Promise((resolve: (value: HTMLElement) => void) => {\n        const elements = document.querySelectorAll(\n            selectorAll\n        ) as NodeListOf<HTMLElement>\n        for (let i = 0; i < elements.length; i++) {\n            const element = elements[i]\n            if (element.textContent === textContent) {\n                colorConsole(\n                    `${element}: found textContent immediately: ${textContent}...`,\n                    'green',\n                    element\n                )\n                resolve(element)\n            }\n        }\n\n        const observer = new MutationObserver((mutations) => {\n            mutations.forEach((mutation) => {\n                const elements = document.querySelectorAll(\n                    selectorAll\n                ) as NodeListOf<HTMLElement>\n                for (let i = 0; i < elements.length; i++) {\n                    const element = elements[i]\n                    if (element.textContent === textContent) {\n                        colorConsole(\n                            `${elementName}: found textContent: ${textContent}...`,\n                            'green',\n                            element\n                        )\n                        resolve(element)\n                        observer.disconnect()\n                    }\n                }\n            })\n        })\n        observer.observe(document.body, {\n            childList: true,\n            subtree: true,\n        })\n    })\n}\n", "import { appended } from './index';\nimport { getAddressDivs, colorConsole } from './utils';\nimport { waitForElement, waitForManyElements } from './wait-elements';\n\nexport async function addAddressButtons() {\n    // Check if map buttons already present\n    const labels = await waitForManyElements(\n        '.hl_contact-details-left .form-group .label',\n        20,\n        undefined,\n        'waiting for address labels'\n    );\n    const addressDivs = getAddressDivs(labels);\n    if (!addressDivs) {\n        colorConsole(\n            'no address divs found, returning from startAddButtons',\n            'red'\n        );\n        return;\n    }\n    colorConsole('address divs found... inserting map buttons', 'green');\n    await insertMapButtons(addressDivs);\n}\n\n/**\n * Inserts the map buttons\n * @param {{streetLabel: HTMLElement, streetDiv: HTMLElement, cityDiv: HTMLElement, stateDiv: HTMLElement, zipDiv: HTMLElement}} addressDivs\n */\nexport async function insertMapButtons(addressDivs: AddressDivs) {\n    // const prospectTab = $('#prospect > div:nth-child(2)');\n    if (document.querySelectorAll('.zg-map-btns').length > 0) {\n        colorConsole('map buttons already present, returning', 'yellow');\n        return;\n    }\n    const newDiv = document.createElement('div');\n    newDiv.id = 'mapLinks';\n    newDiv.className = 'mapContainerZG';\n    newDiv.style.display = 'inline-flex';\n    const { streetLabel } = addressDivs;\n    streetLabel.style.display = 'inline-flex';\n    streetLabel.style.width = '50%';\n\n    const addressParams: { [key: string]: string | null } = {\n        street: addressDivs.streetDiv.querySelector('input')?.value ?? null,\n        city: addressDivs.cityDiv.querySelector('input')?.value ?? null,\n        state: addressDivs.stateDiv.querySelector('input')?.value ?? null,\n        zip: addressDivs.stateDiv.querySelector('input')?.value ?? null,\n    };\n\n    // create string of address params separatted by a '-', also for each value if it has a space, only add if not null\n    const zillowParams = encodeURIComponent(\n        Object.values(addressParams)\n            .filter((val) => val !== null)\n            .join(' ')\n    );\n\n    const googleParams = Object.values(addressParams)\n        .filter((val) => val !== null)\n        .map((val) => encodeURIComponent(val as string))\n        .join('+');\n\n    const googleButton = `<span class=\"zillowTitle\">Search:</span><a href=\"https://www.google.com/search?q=${googleParams}\" target=\"_blank\"><img src=\"https://upload.wikimedia.org/wikipedia/commons/5/53/Google_%22G%22_Logo.svg\" class=\"zg-map-btns\"></a>`;\n    const zillowButton = `<a href=\"https://www.zillow.com/homes/for_sale/${zillowParams}_rb\" target=\"_blank\" id=\"zillowLink\"><img src=\"https://www.zillow.com/apple-touch-icon.png\" class=\"zg-map-btns\"></a>`;\n    newDiv.innerHTML = googleButton + zillowButton;\n\n    streetLabel.insertAdjacentElement('afterend', newDiv);\n}\n\nexport async function addSectionToggle() {\n    if (document.getElementById('section-toggle')) {\n        colorConsole('section toggle already present, returning', 'yellow');\n        return;\n    }\n    const checkbox = document.createElement('input');\n    checkbox.type = 'checkbox';\n    checkbox.id = 'section-toggle';\n    checkbox.className =\n        'focus:ring-curious-blue-500 h-5 w-5 text-curious-blue-600 border-gray-300 rounded mr-2 disabled:opacity-50';\n    const label = document.createElement('label');\n    label.htmlFor = 'section-toggle';\n    label.innerText = 'Toggle Sections';\n    label.style.color = 'var(--gray-600)';\n    label.className = 'mb-0 mr-4';\n\n    checkbox.addEventListener('change', toggleSections);\n\n    const toggleDiv = document.createElement('div');\n    toggleDiv.appendChild(checkbox);\n    toggleDiv.appendChild(label);\n    toggleDiv.style.display = 'inline-flex';\n    const { firstElementChild: parentNode } = await waitForElement({\n        selector: '.hl_contact-details-left .h-full.overflow-y-auto', \n    });\n    if (!parentNode) {\n        colorConsole('parent node not found', 'red');\n        return;\n    }\n    parentNode.className += ' text-xs !text-gray-600';\n    parentNode.insertBefore(toggleDiv, parentNode.firstChild);\n    // make other checkbox same style\n    (parentNode.lastElementChild as HTMLDivElement).style.color =\n        'var(--gray-600)';\n}\n\nexport function toggleSections(e: Event) {\n    const checkbox = e.target as HTMLInputElement;\n    if (checkbox.checked) {\n        for (let trigger of appended.contactDivTriggers) {\n            if (trigger.parentElement?.getAttribute('data-open') === 'true') {\n                trigger.click();\n            }\n        }\n    } else {\n        // open all sections when unchecked\n        for (let trigger of appended.contactDivTriggers) {\n            if (trigger.parentElement?.getAttribute('data-open') === 'false') {\n                trigger.click();\n            }\n        }\n    }\n}\n", "export const CONTACT_DIVS_SELECTOR =\n    '.hl_contact-details-left > div > .h-full.overflow-y-auto > .py-3.px-3';\nexport const ACTIONS_DIVS_SELECTOR =\n    '.hl_contact-details-left > div > .h-full.overflow-y-auto > .bg-gray-100 > .py-3.px-3';\nexport const CONTACT_SECTION_LABELS_SELECTOR =\n    '.hl_contact-details-left .form-group .label';\n", "// @ts-nocheck\n\n/**\n * Dialog module.\n * @module dialog.js\n * @version 1.0.0\n * @summary 02-01-2022\n * @author Mads Stoumann\n * @description Custom versions of `alert`, `confirm` and `prompt`, using `<dialog>`\n */\nexport default class Dialog {\n    settings: DialogSettings;\n    dialogSupported?: boolean;\n    dialog?: HTMLDialogElement;\n    elements?: { [key: string]: HTMLElement };\n    focusable?: never[];\n    hasFormData?: boolean;\n\n    constructor(settings: DialogSettings) {\n        // Set default settings\n        this.settings = {\n            accept: settings.accept || 'OK',\n            bodyClass: settings.bodyClass || 'dialog-open',\n            cancel: settings.cancel || 'Cancel',\n            ...settings,\n        };\n        this.init();\n    }\n\n    collectFormData(formData: FormData) {\n        const object: FormDataObject = {};\n        formData.forEach((value, key) => {\n            if (typeof value === 'string') {\n                if (object.hasOwnProperty(key)) {\n                    if (!Array.isArray(object[key])) {\n                        object[key] = [object[key] as string];\n                    }\n                    (object[key] as string[]).push(value);\n                } else {\n                    object[key] = value;\n                }\n            }\n        });\n        return object;\n    }\n\n    getFocusable() {\n        return [\n            ...this.dialog?.querySelectorAll(\n                'button,[href],select,textarea,input:not([type=\"hidden\"]),[tabindex]:not([tabindex=\"-1\"])'\n            ),\n        ];\n    }\n\n    init() {\n        this.dialogSupported = typeof HTMLDialogElement === 'function';\n        this.dialog = document.createElement('dialog');\n        this.dialog.role = 'dialog';\n        this.dialog.dataset.component = this.dialogSupported\n            ? 'dialog'\n            : 'no-dialog';\n        this.dialog.innerHTML = `\n    <form method=\"dialog\" data-ref=\"form\">\n      <fieldset data-ref=\"fieldset\" role=\"document\">\n        <legend data-ref=\"message\" id=\"${Math.round(Date.now()).toString(\n            36\n        )}\"></legend>\n        <div data-ref=\"template\"></div>\n      </fieldset>\n      <menu>\n        <button${\n            this.dialogSupported ? '' : ` type=\"button\"`\n        } data-ref=\"cancel\" value=\"cancel\"></button>\n        <button${\n            this.dialogSupported ? '' : ` type=\"button\"`\n        } data-ref=\"accept\" value=\"default\"></button>\n      </menu>\n      <audio data-ref=\"soundAccept\"></audio>\n      <audio data-ref=\"soundOpen\"></audio>\n    </form>`;\n        document.body.appendChild(this.dialog);\n\n        this.elements = {};\n        this.focusable = [];\n        this.dialog\n            .querySelectorAll('[data-ref]')\n            .forEach((el: HTMLElement) => (this.elements[el.dataset.ref] = el));\n        this.dialog.setAttribute('aria-labelledby', this.elements.message.id);\n        this.elements.cancel.addEventListener('click', () => {\n            this.dialog.dispatchEvent(new Event('cancel'));\n        });\n        this.dialog.addEventListener('keydown', (e) => {\n            if (e.key === 'Enter') {\n                if (!this.dialogSupported) e.preventDefault();\n                this.elements.accept.dispatchEvent(new Event('click'));\n            }\n            if (e.key === 'Escape')\n                this.dialog.dispatchEvent(new Event('cancel'));\n            if (e.key === 'Tab') {\n                e.preventDefault();\n                const len = this.focusable.length - 1;\n                let index = this.focusable.indexOf(e.target);\n                index = e.shiftKey ? index - 1 : index + 1;\n                if (index < 0) index = len;\n                if (index > len) index = 0;\n                this.focusable[index].focus();\n            }\n        });\n        this.toggle();\n    }\n    // Opens the dialog and customizes settings\n    open(settings?: DialogSettings) {\n        const dialog = {\n            ...this.settings,\n            ...settings,\n        };\n        this.dialog.className = dialog.dialogClass || '';\n\n        /* set innerText of the elements */\n        this.elements.accept.innerText = dialog.accept;\n        this.elements.cancel.innerText = dialog.cancel;\n        this.elements.cancel.hidden = dialog.cancel === '';\n        this.elements.message.innerHTML = dialog.message;\n\n        /* If sounds exists, update `src` */\n        this.elements.soundAccept.src = dialog.soundAccept || '';\n        this.elements.soundOpen.src = dialog.soundOpen || '';\n\n        /* A target can be added (from the element invoking the dialog */\n        this.elements.target = dialog.target || '';\n\n        /* Optional HTML for custom dialogs */\n        this.elements.template.innerHTML = dialog.template || '';\n\n        /* Grab focusable elements */\n        this.focusable = this.getFocusable();\n        this.hasFormData = this.elements.fieldset.elements.length > 0;\n        if (dialog.soundOpen) {\n            this.elements.soundOpen.play();\n        }\n        this.toggle(true);\n        if (this.hasFormData) {\n            /* If form elements exist, focus on that first */\n            this.focusable[0].focus();\n            this.focusable[0].select();\n        } else {\n            this.elements.accept.focus();\n        }\n    }\n    // Toggles the dialog open and closed\n    toggle(open = false) {\n        if (this.dialogSupported && open) this.dialog.showModal();\n        if (!this.dialogSupported) {\n            document.body.classList.toggle(this.settings.bodyClass, open);\n        }\n        this.dialog.hidden = !open;\n        if (this.elements.target && !open) {\n            this.elements.target.focus();\n        }\n    }\n    // Wait for user to click accept or cancel\n    waitForUser() {\n        return new Promise(\n            (resolve: (value: boolean | FormDataObject) => void) => {\n                this.dialog.addEventListener(\n                    'cancel',\n                    () => {\n                        this.toggle();\n                        resolve(false);\n                    },\n                    { once: true }\n                );\n                this.elements.accept.addEventListener(\n                    'click',\n                    () => {\n                        let value = this.hasFormData\n                            ? this.collectFormData(\n                                  new FormData(this.elements.form)\n                              )\n                            : true;\n                        if (\n                            this.elements.soundAccept.getAttribute('src')\n                                .length > 0\n                        )\n                            this.elements.soundAccept.play();\n                        this.toggle();\n                        resolve(value);\n                    },\n                    { once: true }\n                );\n            }\n        );\n    }\n\n    // Alert box - set cancel and template to empty string\n    alert(message: string) {\n        const settings: DialogSettings = {\n            message,\n            cancel: '',\n            template: '',\n        };\n\n        this.open(settings);\n        return this.waitForUser();\n    }\n    // Confirm box - set template to empty string\n    confirm(message: string) {\n        const settings: DialogSettings = {\n            message,\n            template: '',\n        };\n        this.open(settings);\n        return this.waitForUser();\n    }\n    // Prompt box - set cancel to empty string\n    prompt(message: string, value: boolean | FormData) {\n        const template = `<label aria-label=\"${message}\"><input type=\"text\" name=\"prompt\" value=\"${value}\"></label>`;\n        const settings: DialogSettings = {\n            message,\n            template,\n        };\n        this.open(settings);\n        return this.waitForUser();\n    }\n}\n", "import { ACTIONS_DIVS_SELECTOR } from './constants'\nimport Dialog from './dialog'\nimport { appended } from './index'\nimport { colorConsole } from './utils'\nimport { waitForElement, waitForManyElements } from './wait-elements'\n\nexport async function addTagElements() {\n    colorConsole(`inserting tag link and tag alert....`, 'blue')\n\n    appended.tagsAdded = []\n    // If the edit tag div is already present, don't add it again\n    if (document.getElementById('tags-edit-container')) {\n        colorConsole('tags edit div already present', 'red')\n        return\n    }\n\n    const actionsSection = (await waitForManyElements(\n        ACTIONS_DIVS_SELECTOR,\n        3,\n        undefined,\n        'addTagElements'\n    )) as NodeListOf<HTMLElement>\n    // Tags section is the first child of the actions container with a heading of \"Tags\"\n    let tagsSection: HTMLDivElement | null = null\n    for (let i = 0; i < actionsSection.length; i++) {\n        const node = actionsSection[i]\n        const heading = node.querySelector('span.text-sm.font-medium')\n        if (heading?.textContent && heading.textContent.trim() === 'Tags') {\n            tagsSection = node.firstElementChild as HTMLDivElement\n            colorConsole(`Tags heading found-> `, 'orange', tagsSection)\n            break\n        }\n    }\n\n    if (tagsSection === null) {\n        colorConsole('tags section not found', 'red')\n        return\n    }\n\n    const newTagDiv = await appendTagLink(tagsSection)\n    if (!newTagDiv) {\n        colorConsole('new tag div not found', 'red')\n        return\n    }\n    colorConsole(`new tag div found -> `, 'green', newTagDiv)\n\n    // Add the new tag alert\n    checkNewTagAlert(newTagDiv)\n}\n\n/**\n * Inserts an \"Edit Tags\" link next to Tags section in Contact Details.\n * @param {HTMLDivElement} tagsSection - the Tags section on contact info screen\n */\nexport async function appendTagLink(tagsSection: HTMLDivElement) {\n    // If the edit tag div is already present, don't add it again\n    if (document.getElementById('tags-edit')) return undefined\n\n    // neeed to insert the edit tags link just before the last child of the tags section\n    const lastChild = tagsSection.lastElementChild\n\n    // Need container to hold the link so the link doesnt grow with flex-grow\n    const tagContainer = document.createElement('div')\n    tagContainer.id = 'tags-edit-container'\n\n    const tagLink = document.createElement('a')\n    // stop the link from propogating up the DOM\n    tagLink.addEventListener('click', (e) => e.stopPropagation())\n    tagLink.href = window.location.href.replace(/contacts.*/, 'settings/tags')\n    tagLink.target = '_blank'\n    tagLink.innerHTML = `<span id=\"tags-edit\" class=\"tags-edit\">Edit Tags  <svg xmlns=\"http://www.w3.org/2000/svg\" x=\"0px\" y=\"0px\"\n  width=\"12\" height=\"12\"\n  viewBox=\"0 0 172 172\"\n  style=\" fill:#000000;\"><g transform=\"\"><g fill=\"none\" fill-rule=\"nonzero\" stroke=\"none\" stroke-width=\"1\" stroke-linecap=\"butt\" stroke-linejoin=\"miter\" stroke-miterlimit=\"10\" stroke-dasharray=\"\" stroke-dashoffset=\"0\" font-family=\"none\" font-weight=\"none\" font-size=\"none\" text-anchor=\"none\" style=\"mix-blend-mode: normal\"><path d=\"M0,172v-172h172v172z\" fill=\"none\"></path><path d=\"\" fill=\"none\"></path><path d=\"\" fill=\"none\"></path><path d=\"\" fill=\"none\"></path><path d=\"\" fill=\"none\"></path><path d=\"\" fill=\"none\"></path><path d=\"\" fill=\"none\"></path><g><path d=\"M5.375,26.875h118.25v118.25h-118.25z\" fill=\"#c2e8ff\"></path><path d=\"M118.25,32.25v107.5h-107.5v-107.5h107.5M129,21.5h-129v129h129v-129z\" fill=\"#357ded\"></path><path d=\"M129,43v32.25h-21.5l0,-32.25z\" fill=\"#c2e8ff\"></path><path d=\"M118.25,21.5v21.5h-32.25v-21.5z\" fill=\"#c2e8ff\"></path><g fill=\"#357ded\"><path d=\"M150.5,0h-64.5l21.5,21.5l-43,43l21.5,21.5l43,-43l21.5,21.5z\"></path></g></g><path d=\"\" fill=\"none\"></path><path d=\"\" fill=\"none\"></path></g></g></svg>\n  </span>`\n\n    tagContainer.prepend(tagLink)\n    tagsSection.insertBefore(tagContainer, lastChild)\n    return tagsSection\n    // Call tagAlert now that section is loaded and link added\n}\n\n/**\n * Checks for the add new tag div on conversations, opportunities and contact details pages.\n * @param {HTMLDivElement} newTagDiv - the Tags div in contact details left panel\n */\nexport async function checkNewTagAlert(newTagDiv?: HTMLDivElement) {\n    if (!newTagDiv) {\n        colorConsole('new tag div not found, waiting for click', 'orange')\n        const addNewTagSection = await waitForElement({\n            selector: '.add-new',\n        })\n\n        return attachTagAlert(addNewTagSection)\n    }\n    const addNewSection = document.querySelector('.add-new') as HTMLElement\n    if (addNewSection) {\n        colorConsole('add new section found', 'orange')\n        return attachTagAlert(addNewSection)\n    } else {\n        colorConsole(\n            'add new section not found, waiting for click',\n            'orange',\n            newTagDiv\n        )\n        newTagDiv.addEventListener('click', async (e) => {\n            const addNew = document.querySelector('.add-new')\n            if (!addNew) {\n                colorConsole(\n                    `click occurred on tag div, but add new not present`,\n                    'red'\n                )\n                return\n            }\n            colorConsole(\n                `click occured on tag div, addNew found`,\n                'green',\n                addNew\n            )\n            const addNewTagDiv = await waitForElement({\n                selector: '.add-new',\n            })\n            colorConsole(\n                `add new tag section loaded -> `,\n                'green',\n                addNewTagDiv\n            )\n            attachTagAlert(addNewTagDiv)\n        })\n    }\n}\n\n/**\n * Attaches click listener for adding new tags\n * @param {HTMLElement} addNew\n */\nexport function attachTagAlert(addNew: HTMLElement) {\n    appended.tagsAdded = []\n    colorConsole(`now attaching tag alert...`)\n\n    if (addNew.hasAttribute('listener'))\n        return colorConsole('tag alert found, returning...')\n    addNew.setAttribute('listener', 'tagAlert')\n\n    addNew.addEventListener(\n        'click',\n        (e) => {\n            addNew.removeAttribute('listener')\n            tagAddClick(e)\n        },\n        {\n            capture: true,\n            once: true,\n        }\n    )\n}\n\n/**\n * @param {Event} e\n */\nasync function tagAddClick(e: Event) {\n    colorConsole(`add new tag click captured`, 'green', e)\n    e.stopPropagation()\n    const target = e.target as HTMLElement\n    const tagText = target.innerText?.trim()\n    // const confirm =  confirmTagAdd(e.target.textContent);\n    const dialog = new Dialog({\n        dialogClass: 'tag-confirm-dialog',\n        accept: 'Yes',\n        cancel: 'No',\n        message: `Are you sure you want to add <span class=\"tag-add\">${tagText}</span> as a new tag?`,\n        target: target,\n    })\n    dialog.open()\n    const confirm = await dialog.waitForUser()\n    colorConsole(`tag add confirmation: ${confirm} for tag ${tagText}`, 'green')\n    // If confirmed, click the 'add' button and continue with adding the tag\n    if (confirm) {\n        appended.tagsAdded.push(tagText)\n        target.click()\n    }\n    setTimeout(checkNewTagAlert, 100)\n}\n", "import { CONTACT_DIVS_SELECTOR, ACTIONS_DIVS_SELECTOR } from './constants';\nimport { appended } from './index';\nimport { colorConsole } from './utils';\nimport { waitForManyElements } from './wait-elements';\n\n/**\n * Opens all the contact divs on the page\n * - Adds the div to the sectionTriggers array so we can open and close it later\n * - Adds the data-open attribute to the div so we know it is open\n * - adds an event listener to keep track of the open state\n */\nexport async function processContactDivs() {\n    const contactDivs = (await waitForManyElements(\n        CONTACT_DIVS_SELECTOR,\n        3,\n        undefined,\n        'processContactDivs: waiting for Contact divs'\n    )) as NodeListOf<HTMLElement>;\n    const actionsSectionDivs = (await waitForManyElements(\n        ACTIONS_DIVS_SELECTOR,\n        3,\n        undefined,\n        'processContactDivs: waiting for Acions section'\n    )) as NodeListOf<HTMLElement>;\n    // path of d attribute when closed is d=\"M9 5l7 7-7 7\"\n    const CLOSED_PATH = 'M9 5l7 7-7 7';\n    // if the svg within the contactDivs or the actionsSection is not visible, then we need to open the div to see the contact info\n    for (let contactDiv of contactDivs) {\n        const contactDivTrigger = contactDiv.querySelector(\n            '.cursor-pointer'\n        ) as HTMLElement;\n\n        // path of d attibute when closed is d=\"M9 5l7 7-7 7\"\n        const path = contactDiv.querySelector('svg > path') as SVGPathElement;\n        if (!path) continue;\n        // add the div to the sectionTriggers array so we can open and close it later\n        appended.contactDivTriggers.push(contactDivTrigger);\n\n        if (path.getAttribute('d') === CLOSED_PATH) {\n            colorConsole('opening contact div', 'green', contactDiv);\n            (contactDiv.firstChild as HTMLElement).click();\n            contactDiv.setAttribute('data-open', 'true');\n        } else {\n            contactDiv.setAttribute('data-open', 'true');\n        }\n        // listen for clicks to keep track of the open state\n        contactDivTrigger.addEventListener('click', (e) => {\n            if (contactDiv.getAttribute('data-open') === 'true') {\n                contactDiv.setAttribute('data-open', 'false');\n            } else {\n                contactDiv.setAttribute('data-open', 'true');\n            }\n        });\n    }\n    for (let action of actionsSectionDivs) {\n        if (!action.childElementCount) {\n            continue;\n        }\n        const actionTrigger = action.querySelector(\n            '.cursor-pointer'\n        ) as HTMLElement;\n\n        appended.contactDivTriggers.push(action);\n\n        // path of d attibute when closed is d=\"M9 5l7 7-7 7\"\n        // select the 2nd svg element because the first is the not the chevron in actions\n        const path = action.querySelectorAll('svg > path')[1] as SVGPathElement;\n        if (path.getAttribute('d') === CLOSED_PATH) {\n            colorConsole('opening actions div', 'green', action);\n            (action.firstChild as HTMLElement).click();\n            action.setAttribute('data-open', 'true');\n        } else {\n            action.setAttribute('data-open', 'true');\n        }\n\n        // listen for clicks to keep track of the open state\n        action.addEventListener('click', (e) => {\n            if (action.getAttribute('data-open') === 'true') {\n                action.setAttribute('data-open', 'false');\n            } else {\n                action.setAttribute('data-open', 'true');\n            }\n        });\n    }\n}\n", "import { CONTACT_DIVS_SELECTOR } from './constants';\nimport { waitForElement, waitForManyElements } from './wait-elements';\n\nexport async function addContactSearchBox() {\n    const parentSelector = '.hl_contact-details-left .contact-detail-nav';\n    const parentNode = (await waitForElement({\n        selector: parentSelector,\n        elementName: 'addContactSearchBox: waiting for parent node',\n    })) as HTMLElement;\n    const searchBox = document.createElement('input');\n    searchBox.setAttribute('type', 'text');\n    searchBox.setAttribute('placeholder', 'search sections');\n    searchBox.setAttribute('id', 'contact-search');\n    searchBox.className =\n        'h-6 basis-36 focus:ring-curious-blue-500 focus:border-curious-blue-500 border border-blue-300 block text-xs  rounded disabled:opacity-50 text-gray-800';\n    // insert the search box after the first child of the parent node\n    parentNode.insertBefore(searchBox, parentNode.children[1]);\n\n    searchBox.addEventListener('input', async (e) => {\n        const searchValue = (e.target as HTMLInputElement).value;\n        if (!searchValue) {\n            return;\n        }\n\n        const contactDivs = (await waitForManyElements(\n            CONTACT_DIVS_SELECTOR,\n            20,\n            undefined,\n            'addContactSearchBox'\n        )) as NodeListOf<HTMLElement>;\n        for (let div of contactDivs) {\n            if (\n                div.textContent\n                    ?.toLowerCase()\n                    .includes(searchValue.toLowerCase())\n            ) {\n                div.style.backgroundColor = 'yellow';\n                div.scrollIntoView({ behavior: 'smooth', block: 'center' });\n                break;\n            } else {\n                div.style.backgroundColor = 'transparent';\n            }\n        }\n    });\n}\n\n// scroll to section label as user types\n// searchBox.addEventListener('keyup', async (e) => {\n//     const searchValue = (e.target as HTMLInputElement).value;\n//     if (!searchValue) {\n//         return;\n//     }\n//     const sectionLabels = (await waitForManyElements(\n//         CONTACT_SECTION_LABELS_SELECTOR,\n//         20\n//     )) as NodeListOf<HTMLElement>;\n//     for (let label of sectionLabels) {\n//         if (\n//             label.textContent\n//                 ?.toLowerCase()\n//                 .includes(searchValue.toLowerCase())\n//         ) {\n//             label.style.backgroundColor = 'yellow';\n//             label.scrollIntoView({ behavior: 'smooth', block: 'center' });\n//             break;\n//         } else {\n//             label.style.backgroundColor = 'transparent';\n//         }\n//     }\n// });\n// searchBox.addEventListener('blur', async () => {\n//     const sectionLabels = (await waitForManyElements(\n//         CONTACT_SECTION_LABELS_SELECTOR,\n//         20\n//     )) as NodeListOf<HTMLElement>;\n//     for (let label of sectionLabels) {\n//         label.style.backgroundColor = 'transparent';\n//     }\n// });\n", "import Dialog from './dialog';\nimport { colorConsole } from './utils';\nimport { waitForElement } from './wait-elements';\n\nexport async function attachSaveAlert() {\n    const formFooter = await waitForElement({\n        selector: '.form-footer.save',\n        elementName: 'attachSaveAlert:',\n    });\n    if (formFooter.hasAttribute('listener')) return;\n    formFooter.setAttribute('listener', 'saveAlert');\n    const pageLinks = document.querySelectorAll(\n        'a[href], a.back'\n    ) as NodeListOf<HTMLAnchorElement>;\n    pageLinks.forEach((ahref: HTMLAnchorElement) => {\n        ahref.addEventListener('click', handleSaveAlert, {\n            once: true,\n            capture: true,\n        });\n    });\n}\n\nfunction getNumChanges() {\n    const targetDiv = document.querySelector('.form-footer.save > div');\n    const changesText = targetDiv?.textContent;\n    const match = changesText?.match(/^\\d+/);\n    return match ? +match[0] : null;\n}\n\nasync function handleSaveAlert(e: MouseEvent) {\n    e.preventDefault();\n    console.log('trying to exit without saving');\n    const numChanges = getNumChanges();\n\n    const target = e.target as HTMLElement;\n    const dialog = new Dialog({\n        dialogClass: 'confirm-dialog',\n        accept: 'Save Changes',\n        cancel: 'Discard Changes',\n        message:\n            'You have ' +\n            `${numChanges ? numChanges + ' ' : ''}` +\n            'unsaved changes.',\n        target: target,\n    });\n\n    dialog.open();\n\n    const confirm = await dialog.waitForUser();\n    colorConsole(`save alert confirmation: ${confirm}`, 'green');\n    if (confirm) {\n        colorConsole('saving changes...', 'green');\n        (\n            document.querySelector(\n                '.form-footer.save div:nth-child(2) > div > button'\n            ) as HTMLButtonElement\n        ).click();\n    }\n}\n", "import { waitForManyElements } from './wait-elements'\n\nexport async function changeFontAwesomeIcons() {\n    const pencilIcons = (await waitForManyElements(\n        'i.fas.fa-pencil-alt',\n        1,\n        undefined,\n        'updatePhoneNumberIcon'\n    )) as NodeListOf<HTMLElement>\n    pencilIcons.forEach((icon) => (icon.className = 'icon icon-pencil --light'))\n\n    const trashIcons = (await waitForManyElements(\n        'i.fas.fa-trash-alt',\n        1,\n        undefined,\n        'deletePhoneNumberIcon'\n    )) as NodeListOf<HTMLElement>\n    trashIcons.forEach((icon) => (icon.className = 'icon icon-trash --light'))\n}\n"],
  "mappings": ";m9BAAA,IAAAA,GAAA,GAAAC,EAAAD,GAAA,uBAAAE,EAAA,wBAAAC,EAAA,mBAAAC,EAAA,kBAAAC,EAAA,aAAAC,EAAA,qBAAAC,EAAA,iBAAAC,EAAA,cAAAC,EAAA,mBAAAC,EAAA,uBAAAC,EAAA,iCAAAC,EAAA,mCAAAC,EAAA,qBAAAC,EAAA,SAAAC,ICKO,SAASC,EAAeC,EAAkB,CALjD,IAAAC,EAOI,IAAIC,EACJ,QAASC,KAASH,EACd,GACIG,EAAM,aACNA,EAAM,YAAY,KAAK,IAAM,iBAC/B,CAKE,GAHAD,GAAsBD,EAAAE,EAAsB,QACxC,aACJ,IAFsB,YAAAF,EAEnB,SACC,CAACC,EAAoB,CACrBE,EAAa,oCAAqC,KAAK,EACvD,OAGJ,IAAMC,EAA2B,CAC7B,YAAaF,EACb,UAAWD,EAAmB,CAAC,EAC/B,QAASA,EAAmB,CAAC,EAC7B,SAAUA,EAAmB,CAAC,EAC9B,OAAQA,EAAmB,CAAC,EAC5B,mBAAoBA,CACxB,EAEA,OAAAI,EAAS,YAAcD,EAChBA,EAGnB,CAEO,SAASD,EACZG,EACAC,EACAC,EACF,CACE,IAAMC,EAAW,CACb,IAAK,UACL,MAAO,UACP,KAAM,UACN,OAAQ,UACR,OAAQ,SACZ,EAEAF,GAAA,OAAAA,EAAU,QAEV,QAAQ,IACJ,gBAASD,IACT,2BAA2BG,EAASF,CAAK,KACzCC,CACJ,CACJ,CCzDA,IAAAE,EAAA,GAAAC,EAAAD,EAAA,oBAAAE,EAAA,wBAAAC,EAAA,uBAAAC,IAOO,SAASC,EAAeC,EAAc,CACzC,GAAM,CAAE,YAAAC,EAAa,SAAAC,CAAS,EAAIF,EAElC,OAAAC,GACIE,EAAa,GAAGF,mBAA6BD,EAAM,UAAU,EAC1D,IAAI,QACP,CACII,EACAC,IACC,CACD,IAAMC,EAAU,SAAS,cAAcJ,CAAQ,EAC/C,GAAII,EAAS,CACTF,EAAQE,CAAO,EACf,OAGJ,IAAMC,EAAW,IAAI,iBAAkBC,GAAc,CACjDA,EAAU,QAASC,GAAa,CACd,MAAM,KAAKA,EAAS,UAAU,EACtC,QAASC,GAAS,CACpB,GAAIA,aAAgB,YAAa,CAC7B,IAAMJ,EAAUI,EAAK,cAAcR,CAAQ,EACvCQ,EAAK,QAAQR,CAAQ,IACrBC,EACI,GAAGF,gBAA0BC,OAC7B,QACAQ,CACJ,EACAH,EAAS,WAAW,EACpBH,EAAQM,CAAI,GAGxB,CAAC,CACL,CAAC,EAED,WAAW,IAAM,CACbP,EACI,GAAGF,OAAiBC,iCACpB,QACJ,EACAK,EAAS,WAAW,EACpBF,EACI,IAAI,MACA,GAAGJ,iCACP,CACJ,CACJ,EAAG,GAAI,CACX,CAAC,EAEDM,EAAS,QAAQ,SAAS,KAAM,CAC5B,UAAW,GACX,QAAS,EACb,CAAC,CACL,CACJ,CACJ,CAWO,SAASI,EACZC,EACAC,EAAc,EACdC,EACAb,EACF,CACE,OAAAE,EACI,GAAGF,kBAA4BY,iBAA2BZ,KACtDa,EAAc,oBAAoBA,IAAgB,IAE1D,EACO,IAAI,QACP,CACIV,EACAC,IACC,CACD,IAAMU,EAAW,SAAS,iBAAiBH,CAAW,EAClDG,EAAS,QAAUF,IACnBV,EACI,GAAGF,0BAAoCY,aACvC,QACAE,CACJ,EACAX,EAAQW,CAAQ,GAGpB,IAAMR,EAAW,IAAI,iBAAkBC,GAAc,CACjDL,EACI,YAAYF,yBACZ,QACJ,EACAO,EAAU,QAASC,GAAa,CAC5B,IAAMM,EAAW,SAAS,iBAAiBH,CAAW,EAClDG,EAAS,QAAUF,IACnBV,EACI,GAAGF,MAAgBA,sBAAgCY,aACnD,QACAE,CACJ,EACAX,EAAQW,CAAQ,EAChBR,EAAS,WAAW,EAE5B,CAAC,EAED,WAAW,IAAM,CACbJ,EACI,GAAGF,MAAgBA,yBAAmCY,6BACtD,QACJ,EACAN,EAAS,WAAW,EACpBF,EACI,IAAI,MACA,GAAGJ,iBAA2BY,yBAClC,CACJ,CACJ,EAAG,GAAI,CACX,CAAC,EAEDN,EAAS,QAAQ,SAAS,KAAM,CAC5B,UAAW,GACX,QAAS,EACb,CAAC,CACL,CACJ,CACJ,CAQO,SAASS,EACZJ,EACAE,EACAb,EACF,CACE,OAAO,IAAI,QAASG,GAA0C,CAC1D,IAAMW,EAAW,SAAS,iBACtBH,CACJ,EACA,QAASK,EAAI,EAAGA,EAAIF,EAAS,OAAQE,IAAK,CACtC,IAAMX,EAAUS,EAASE,CAAC,EACtBX,EAAQ,cAAgBQ,IACxBX,EACI,GAAGG,qCAA2CQ,OAC9C,QACAR,CACJ,EACAF,EAAQE,CAAO,GAIvB,IAAMC,EAAW,IAAI,iBAAkBC,GAAc,CACjDA,EAAU,QAASC,GAAa,CAC5B,IAAMM,EAAW,SAAS,iBACtBH,CACJ,EACA,QAASK,EAAI,EAAGA,EAAIF,EAAS,OAAQE,IAAK,CACtC,IAAMX,EAAUS,EAASE,CAAC,EACtBX,EAAQ,cAAgBQ,IACxBX,EACI,GAAGF,yBAAmCa,OACtC,QACAR,CACJ,EACAF,EAAQE,CAAO,EACfC,EAAS,WAAW,GAGhC,CAAC,CACL,CAAC,EACDA,EAAS,QAAQ,SAAS,KAAM,CAC5B,UAAW,GACX,QAAS,EACb,CAAC,CACL,CAAC,CACL,CC1LA,SAAsBW,GAAoB,QAAAC,EAAA,sBAEtC,IAAMC,EAAS,MAAMC,EACjB,8CACA,GACA,OACA,4BACJ,EACMC,EAAcC,EAAeH,CAAM,EACzC,GAAI,CAACE,EAAa,CACdE,EACI,wDACA,KACJ,EACA,OAEJA,EAAa,8CAA+C,OAAO,EACnE,MAAMC,EAAiBH,CAAW,CACtC,GAMA,SAAsBG,EAAiBH,EAA0B,QAAAH,EAAA,sBA5BjE,IAAAO,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EA8BI,GAAI,SAAS,iBAAiB,cAAc,EAAE,OAAS,EAAG,CACtDT,EAAa,yCAA0C,QAAQ,EAC/D,OAEJ,IAAMU,EAAS,SAAS,cAAc,KAAK,EAC3CA,EAAO,GAAK,WACZA,EAAO,UAAY,iBACnBA,EAAO,MAAM,QAAU,cACvB,GAAM,CAAE,YAAAC,CAAY,EAAIb,EACxBa,EAAY,MAAM,QAAU,cAC5BA,EAAY,MAAM,MAAQ,MAE1B,IAAMC,EAAkD,CACpD,QAAQT,GAAAD,EAAAJ,EAAY,UAAU,cAAc,OAAO,IAA3C,YAAAI,EAA8C,QAA9C,KAAAC,EAAuD,KAC/D,MAAME,GAAAD,EAAAN,EAAY,QAAQ,cAAc,OAAO,IAAzC,YAAAM,EAA4C,QAA5C,KAAAC,EAAqD,KAC3D,OAAOE,GAAAD,EAAAR,EAAY,SAAS,cAAc,OAAO,IAA1C,YAAAQ,EAA6C,QAA7C,KAAAC,EAAsD,KAC7D,KAAKE,GAAAD,EAAAV,EAAY,SAAS,cAAc,OAAO,IAA1C,YAAAU,EAA6C,QAA7C,KAAAC,EAAsD,IAC/D,EAGMI,EAAe,mBACjB,OAAO,OAAOD,CAAa,EACtB,OAAQE,GAAQA,IAAQ,IAAI,EAC5B,KAAK,GAAG,CACjB,EAOMC,EAAe,oFALA,OAAO,OAAOH,CAAa,EAC3C,OAAQE,GAAQA,IAAQ,IAAI,EAC5B,IAAKA,GAAQ,mBAAmBA,CAAa,CAAC,EAC9C,KAAK,GAAG,qIAGPE,EAAe,kDAAkDH,wHACvEH,EAAO,UAAYK,EAAeC,EAElCL,EAAY,sBAAsB,WAAYD,CAAM,CACxD,GAEA,SAAsBO,GAAmB,QAAAtB,EAAA,sBACrC,GAAI,SAAS,eAAe,gBAAgB,EAAG,CAC3CK,EAAa,4CAA6C,QAAQ,EAClE,OAEJ,IAAMkB,EAAW,SAAS,cAAc,OAAO,EAC/CA,EAAS,KAAO,WAChBA,EAAS,GAAK,iBACdA,EAAS,UACL,6GACJ,IAAMC,EAAQ,SAAS,cAAc,OAAO,EAC5CA,EAAM,QAAU,iBAChBA,EAAM,UAAY,kBAClBA,EAAM,MAAM,MAAQ,kBACpBA,EAAM,UAAY,YAElBD,EAAS,iBAAiB,SAAUE,EAAc,EAElD,IAAMC,EAAY,SAAS,cAAc,KAAK,EAC9CA,EAAU,YAAYH,CAAQ,EAC9BG,EAAU,YAAYF,CAAK,EAC3BE,EAAU,MAAM,QAAU,cAC1B,GAAM,CAAE,kBAAmBC,CAAW,EAAI,MAAMC,EAAe,CAC3D,SAAU,kDACd,CAAC,EACD,GAAI,CAACD,EAAY,CACbtB,EAAa,wBAAyB,KAAK,EAC3C,OAEJsB,EAAW,WAAa,0BACxBA,EAAW,aAAaD,EAAWC,EAAW,UAAU,EAEvDA,EAAW,iBAAoC,MAAM,MAClD,iBACR,GAEO,SAASF,GAAeI,EAAU,CAxGzC,IAAAtB,EAAAC,EA0GI,GADiBqB,EAAE,OACN,QACT,QAASC,KAAWC,EAAS,qBACrBxB,EAAAuB,EAAQ,gBAAR,YAAAvB,EAAuB,aAAa,gBAAiB,QACrDuB,EAAQ,MAAM,MAKtB,SAASA,KAAWC,EAAS,qBACrBvB,EAAAsB,EAAQ,gBAAR,YAAAtB,EAAuB,aAAa,gBAAiB,SACrDsB,EAAQ,MAAM,CAI9B,CCxHA,IAAAE,EAAA,GAAAC,EAAAD,EAAA,2BAAAE,EAAA,0BAAAC,EAAA,oCAAAC,KAAO,IAAMD,EACT,wEACSD,EACT,uFACSE,GACT,8CCKJ,IAAqBC,EAArB,KAA4B,CAQxB,YAAYC,EAA0B,CAPtCC,EAAA,iBACAA,EAAA,wBACAA,EAAA,eACAA,EAAA,iBACAA,EAAA,kBACAA,EAAA,oBAII,KAAK,SAAWC,EAAA,CACZ,OAAQF,EAAS,QAAU,KAC3B,UAAWA,EAAS,WAAa,cACjC,OAAQA,EAAS,QAAU,UACxBA,GAEP,KAAK,KAAK,CACd,CAEA,gBAAgBG,EAAoB,CAChC,IAAMC,EAAyB,CAAC,EAChC,OAAAD,EAAS,QAAQ,CAACE,EAAOC,IAAQ,CACzB,OAAOD,GAAU,WACbD,EAAO,eAAeE,CAAG,GACpB,MAAM,QAAQF,EAAOE,CAAG,CAAC,IAC1BF,EAAOE,CAAG,EAAI,CAACF,EAAOE,CAAG,CAAW,GAEvCF,EAAOE,CAAG,EAAe,KAAKD,CAAK,GAEpCD,EAAOE,CAAG,EAAID,EAG1B,CAAC,EACMD,CACX,CAEA,cAAe,CA9CnB,IAAAG,EA+CQ,MAAO,CACH,IAAGA,EAAA,KAAK,SAAL,YAAAA,EAAa,iBACZ,2FAER,CACJ,CAEA,MAAO,CACH,KAAK,gBAAkB,OAAO,mBAAsB,WACpD,KAAK,OAAS,SAAS,cAAc,QAAQ,EAC7C,KAAK,OAAO,KAAO,SACnB,KAAK,OAAO,QAAQ,UAAY,KAAK,gBAC/B,SACA,YACN,KAAK,OAAO,UAAY;AAAA;AAAA;AAAA,yCAGS,KAAK,MAAM,KAAK,IAAI,CAAC,EAAE,SACpD,EACJ;AAAA;AAAA;AAAA;AAAA,iBAKI,KAAK,gBAAkB,GAAK;AAAA,iBAG5B,KAAK,gBAAkB,GAAK;AAAA;AAAA;AAAA;AAAA,aAMhC,SAAS,KAAK,YAAY,KAAK,MAAM,EAErC,KAAK,SAAW,CAAC,EACjB,KAAK,UAAY,CAAC,EAClB,KAAK,OACA,iBAAiB,YAAY,EAC7B,QAASC,GAAqB,KAAK,SAASA,EAAG,QAAQ,GAAG,EAAIA,CAAG,EACtE,KAAK,OAAO,aAAa,kBAAmB,KAAK,SAAS,QAAQ,EAAE,EACpE,KAAK,SAAS,OAAO,iBAAiB,QAAS,IAAM,CACjD,KAAK,OAAO,cAAc,IAAI,MAAM,QAAQ,CAAC,CACjD,CAAC,EACD,KAAK,OAAO,iBAAiB,UAAY,GAAM,CAO3C,GANI,EAAE,MAAQ,UACL,KAAK,iBAAiB,EAAE,eAAe,EAC5C,KAAK,SAAS,OAAO,cAAc,IAAI,MAAM,OAAO,CAAC,GAErD,EAAE,MAAQ,UACV,KAAK,OAAO,cAAc,IAAI,MAAM,QAAQ,CAAC,EAC7C,EAAE,MAAQ,MAAO,CACjB,EAAE,eAAe,EACjB,IAAMC,EAAM,KAAK,UAAU,OAAS,EAChCC,EAAQ,KAAK,UAAU,QAAQ,EAAE,MAAM,EAC3CA,EAAQ,EAAE,SAAWA,EAAQ,EAAIA,EAAQ,EACrCA,EAAQ,IAAGA,EAAQD,GACnBC,EAAQD,IAAKC,EAAQ,GACzB,KAAK,UAAUA,CAAK,EAAE,MAAM,EAEpC,CAAC,EACD,KAAK,OAAO,CAChB,CAEA,KAAKV,EAA2B,CAC5B,IAAMW,EAAST,IAAA,GACR,KAAK,UACLF,GAEP,KAAK,OAAO,UAAYW,EAAO,aAAe,GAG9C,KAAK,SAAS,OAAO,UAAYA,EAAO,OACxC,KAAK,SAAS,OAAO,UAAYA,EAAO,OACxC,KAAK,SAAS,OAAO,OAASA,EAAO,SAAW,GAChD,KAAK,SAAS,QAAQ,UAAYA,EAAO,QAGzC,KAAK,SAAS,YAAY,IAAMA,EAAO,aAAe,GACtD,KAAK,SAAS,UAAU,IAAMA,EAAO,WAAa,GAGlD,KAAK,SAAS,OAASA,EAAO,QAAU,GAGxC,KAAK,SAAS,SAAS,UAAYA,EAAO,UAAY,GAGtD,KAAK,UAAY,KAAK,aAAa,EACnC,KAAK,YAAc,KAAK,SAAS,SAAS,SAAS,OAAS,EACxDA,EAAO,WACP,KAAK,SAAS,UAAU,KAAK,EAEjC,KAAK,OAAO,EAAI,EACZ,KAAK,aAEL,KAAK,UAAU,CAAC,EAAE,MAAM,EACxB,KAAK,UAAU,CAAC,EAAE,OAAO,GAEzB,KAAK,SAAS,OAAO,MAAM,CAEnC,CAEA,OAAOC,EAAO,GAAO,CACb,KAAK,iBAAmBA,GAAM,KAAK,OAAO,UAAU,EACnD,KAAK,iBACN,SAAS,KAAK,UAAU,OAAO,KAAK,SAAS,UAAWA,CAAI,EAEhE,KAAK,OAAO,OAAS,CAACA,EAClB,KAAK,SAAS,QAAU,CAACA,GACzB,KAAK,SAAS,OAAO,MAAM,CAEnC,CAEA,aAAc,CACV,OAAO,IAAI,QACNC,GAAuD,CACpD,KAAK,OAAO,iBACR,SACA,IAAM,CACF,KAAK,OAAO,EACZA,EAAQ,EAAK,CACjB,EACA,CAAE,KAAM,EAAK,CACjB,EACA,KAAK,SAAS,OAAO,iBACjB,QACA,IAAM,CACF,IAAIR,EAAQ,KAAK,YACX,KAAK,gBACD,IAAI,SAAS,KAAK,SAAS,IAAI,CACnC,EACA,GAEF,KAAK,SAAS,YAAY,aAAa,KAAK,EACvC,OAAS,GAEd,KAAK,SAAS,YAAY,KAAK,EACnC,KAAK,OAAO,EACZQ,EAAQR,CAAK,CACjB,EACA,CAAE,KAAM,EAAK,CACjB,CACJ,CACJ,CACJ,CAGA,MAAMS,EAAiB,CACnB,IAAMd,EAA2B,CAC7B,QAAAc,EACA,OAAQ,GACR,SAAU,EACd,EAEA,YAAK,KAAKd,CAAQ,EACX,KAAK,YAAY,CAC5B,CAEA,QAAQc,EAAiB,CACrB,IAAMd,EAA2B,CAC7B,QAAAc,EACA,SAAU,EACd,EACA,YAAK,KAAKd,CAAQ,EACX,KAAK,YAAY,CAC5B,CAEA,OAAOc,EAAiBT,EAA2B,CAC/C,IAAMU,EAAW,sBAAsBD,8CAAoDT,cACrFL,EAA2B,CAC7B,QAAAc,EACA,SAAAC,CACJ,EACA,YAAK,KAAKf,CAAQ,EACX,KAAK,YAAY,CAC5B,CACJ,EC1NA,SAAsBgB,GAAiB,QAAAC,EAAA,sBAKnC,GAJAC,EAAa,uCAAwC,MAAM,EAE3DC,EAAS,UAAY,CAAC,EAElB,SAAS,eAAe,qBAAqB,EAAG,CAChDD,EAAa,gCAAiC,KAAK,EACnD,OAGJ,IAAME,EAAkB,MAAMC,EAC1BC,EACA,EACA,OACA,gBACJ,EAEIC,EAAqC,KACzC,QAASC,EAAI,EAAGA,EAAIJ,EAAe,OAAQI,IAAK,CAC5C,IAAMC,EAAOL,EAAeI,CAAC,EACvBE,EAAUD,EAAK,cAAc,0BAA0B,EAC7D,GAAIC,GAAA,MAAAA,EAAS,aAAeA,EAAQ,YAAY,KAAK,IAAM,OAAQ,CAC/DH,EAAcE,EAAK,kBACnBP,EAAa,wBAAyB,SAAUK,CAAW,EAC3D,OAIR,GAAIA,IAAgB,KAAM,CACtBL,EAAa,yBAA0B,KAAK,EAC5C,OAGJ,IAAMS,EAAY,MAAMC,EAAcL,CAAW,EACjD,GAAI,CAACI,EAAW,CACZT,EAAa,wBAAyB,KAAK,EAC3C,OAEJA,EAAa,wBAAyB,QAASS,CAAS,EAGxDE,EAAiBF,CAAS,CAC9B,GAMA,SAAsBC,EAAcL,EAA6B,QAAAN,EAAA,sBAE7D,GAAI,SAAS,eAAe,WAAW,EAAG,OAG1C,IAAMa,EAAYP,EAAY,iBAGxBQ,EAAe,SAAS,cAAc,KAAK,EACjDA,EAAa,GAAK,sBAElB,IAAMC,EAAU,SAAS,cAAc,GAAG,EAE1C,OAAAA,EAAQ,iBAAiB,QAAUC,GAAMA,EAAE,gBAAgB,CAAC,EAC5DD,EAAQ,KAAO,OAAO,SAAS,KAAK,QAAQ,aAAc,eAAe,EACzEA,EAAQ,OAAS,SACjBA,EAAQ,UAAY;AAAA;AAAA;AAAA;AAAA,WAMpBD,EAAa,QAAQC,CAAO,EAC5BT,EAAY,aAAaQ,EAAcD,CAAS,EACzCP,CAEX,GAMA,SAAsBM,EAAiBF,EAA4B,QAAAV,EAAA,sBAC/D,GAAI,CAACU,EAAW,CACZT,EAAa,2CAA4C,QAAQ,EACjE,IAAMgB,EAAmB,MAAMC,EAAe,CAC1C,SAAU,UACd,CAAC,EAED,OAAOC,EAAeF,CAAgB,EAE1C,IAAMG,EAAgB,SAAS,cAAc,UAAU,EACvD,GAAIA,EACA,OAAAnB,EAAa,wBAAyB,QAAQ,EACvCkB,EAAeC,CAAa,EAEnCnB,EACI,+CACA,SACAS,CACJ,EACAA,EAAU,iBAAiB,QAAgBM,GAAMhB,EAAA,sBAC7C,IAAMqB,EAAS,SAAS,cAAc,UAAU,EAChD,GAAI,CAACA,EAAQ,CACTpB,EACI,qDACA,KACJ,EACA,OAEJA,EACI,yCACA,QACAoB,CACJ,EACA,IAAMC,EAAe,MAAMJ,EAAe,CACtC,SAAU,UACd,CAAC,EACDjB,EACI,iCACA,QACAqB,CACJ,EACAH,EAAeG,CAAY,CAC/B,EAAC,CAET,GAMO,SAASH,EAAeE,EAAqB,CAIhD,GAHAnB,EAAS,UAAY,CAAC,EACtBD,EAAa,4BAA4B,EAErCoB,EAAO,aAAa,UAAU,EAC9B,OAAOpB,EAAa,+BAA+B,EACvDoB,EAAO,aAAa,WAAY,UAAU,EAE1CA,EAAO,iBACH,QACC,GAAM,CACHA,EAAO,gBAAgB,UAAU,EACjCE,GAAY,CAAC,CACjB,EACA,CACI,QAAS,GACT,KAAM,EACV,CACJ,CACJ,CAKA,SAAeA,GAAYP,EAAU,QAAAhB,EAAA,sBAhKrC,IAAAwB,EAiKIvB,EAAa,6BAA8B,QAASe,CAAC,EACrDA,EAAE,gBAAgB,EAClB,IAAMS,EAAST,EAAE,OACXU,GAAUF,EAAAC,EAAO,YAAP,YAAAD,EAAkB,OAE5BG,EAAS,IAAIC,EAAO,CACtB,YAAa,qBACb,OAAQ,MACR,OAAQ,KACR,QAAS,sDAAsDF,yBAC/D,OAAQD,CACZ,CAAC,EACDE,EAAO,KAAK,EACZ,IAAME,EAAU,MAAMF,EAAO,YAAY,EACzC1B,EAAa,yBAAyB4B,aAAmBH,IAAW,OAAO,EAEvEG,IACA3B,EAAS,UAAU,KAAKwB,CAAO,EAC/BD,EAAO,MAAM,GAEjB,WAAWb,EAAkB,GAAG,CACpC,GC3KA,SAAsBkB,GAAqB,QAAAC,EAAA,sBACvC,IAAMC,EAAe,MAAMC,EACvBC,EACA,EACA,OACA,8CACJ,EACMC,EAAsB,MAAMF,EAC9BG,EACA,EACA,OACA,gDACJ,EAEMC,EAAc,eAEpB,QAASC,KAAcN,EAAa,CAChC,IAAMO,EAAoBD,EAAW,cACjC,iBACJ,EAGME,EAAOF,EAAW,cAAc,YAAY,EAC7CE,IAELC,EAAS,mBAAmB,KAAKF,CAAiB,EAE9CC,EAAK,aAAa,GAAG,IAAMH,IAC3BK,EAAa,sBAAuB,QAASJ,CAAU,EACtDA,EAAW,WAA2B,MAAM,GAC7CA,EAAW,aAAa,YAAa,MAAM,EAK/CC,EAAkB,iBAAiB,QAAUI,GAAM,CAC3CL,EAAW,aAAa,WAAW,IAAM,OACzCA,EAAW,aAAa,YAAa,OAAO,EAE5CA,EAAW,aAAa,YAAa,MAAM,CAEnD,CAAC,GAEL,QAASM,KAAUT,EAAoB,CACnC,GAAI,CAACS,EAAO,kBACR,SAEJ,IAAMC,EAAgBD,EAAO,cACzB,iBACJ,EAEAH,EAAS,mBAAmB,KAAKG,CAAM,EAI1BA,EAAO,iBAAiB,YAAY,EAAE,CAAC,EAC3C,aAAa,GAAG,IAAMP,IAC3BK,EAAa,sBAAuB,QAASE,CAAM,EAClDA,EAAO,WAA2B,MAAM,GACzCA,EAAO,aAAa,YAAa,MAAM,EAM3CA,EAAO,iBAAiB,QAAUD,GAAM,CAChCC,EAAO,aAAa,WAAW,IAAM,OACrCA,EAAO,aAAa,YAAa,OAAO,EAExCA,EAAO,aAAa,YAAa,MAAM,CAE/C,CAAC,EAET,GCjFA,SAAsBE,GAAsB,QAAAC,EAAA,sBAExC,IAAMC,EAAc,MAAMC,EAAe,CACrC,SAFmB,+CAGnB,YAAa,8CACjB,CAAC,EACKC,EAAY,SAAS,cAAc,OAAO,EAChDA,EAAU,aAAa,OAAQ,MAAM,EACrCA,EAAU,aAAa,cAAe,iBAAiB,EACvDA,EAAU,aAAa,KAAM,gBAAgB,EAC7CA,EAAU,UACN,yJAEJF,EAAW,aAAaE,EAAWF,EAAW,SAAS,CAAC,CAAC,EAEzDE,EAAU,iBAAiB,QAAgBC,GAAMJ,EAAA,sBAlBrD,IAAAK,EAmBQ,IAAMC,EAAeF,EAAE,OAA4B,MACnD,GAAI,CAACE,EACD,OAGJ,IAAMC,EAAe,MAAMC,EACvBC,EACA,GACA,OACA,qBACJ,EACA,QAASC,KAAOH,EACZ,IACIF,EAAAK,EAAI,cAAJ,MAAAL,EACM,cACD,SAASC,EAAY,YAAY,GACxC,CACEI,EAAI,MAAM,gBAAkB,SAC5BA,EAAI,eAAe,CAAE,SAAU,SAAU,MAAO,QAAS,CAAC,EAC1D,WAEAA,EAAI,MAAM,gBAAkB,aAGxC,EAAC,CACL,GCxCA,SAAsBC,GAAkB,QAAAC,EAAA,sBACpC,IAAMC,EAAa,MAAMC,EAAe,CACpC,SAAU,oBACV,YAAa,kBACjB,CAAC,EACD,GAAID,EAAW,aAAa,UAAU,EAAG,OACzCA,EAAW,aAAa,WAAY,WAAW,EAC7B,SAAS,iBACvB,iBACJ,EACU,QAASE,GAA6B,CAC5CA,EAAM,iBAAiB,QAASC,GAAiB,CAC7C,KAAM,GACN,QAAS,EACb,CAAC,CACL,CAAC,CACL,GAEA,SAASC,IAAgB,CACrB,IAAMC,EAAY,SAAS,cAAc,yBAAyB,EAC5DC,EAAcD,GAAA,YAAAA,EAAW,YACzBE,EAAQD,GAAA,YAAAA,EAAa,MAAM,QACjC,OAAOC,EAAQ,CAACA,EAAM,CAAC,EAAI,IAC/B,CAEA,SAAeJ,GAAgBK,EAAe,QAAAT,EAAA,sBAC1CS,EAAE,eAAe,EACjB,QAAQ,IAAI,+BAA+B,EAC3C,IAAMC,EAAaL,GAAc,EAE3BM,EAASF,EAAE,OACXG,EAAS,IAAIC,EAAO,CACtB,YAAa,iBACb,OAAQ,eACR,OAAQ,kBACR,QACI,YACGH,EAAaA,EAAa,IAAM,qBAEvC,OAAQC,CACZ,CAAC,EAEDC,EAAO,KAAK,EAEZ,IAAME,EAAU,MAAMF,EAAO,YAAY,EACzCG,EAAa,4BAA4BD,IAAW,OAAO,EACvDA,IACAC,EAAa,oBAAqB,OAAO,EAErC,SAAS,cACL,mDACJ,EACF,MAAM,EAEhB,GCxDA,SAAsBC,GAAyB,QAAAC,EAAA,uBACtB,MAAMC,EACvB,sBACA,EACA,OACA,uBACJ,GACY,QAASC,GAAUA,EAAK,UAAY,0BAA2B,GAEvD,MAAMD,EACtB,qBACA,EACA,OACA,uBACJ,GACW,QAASC,GAAUA,EAAK,UAAY,yBAA0B,CAC7E,GVRO,IAAMC,EAAwB,CACjC,YAAa,CAAC,EACd,UAAW,CAAC,EACZ,YAAa,CAAC,EACd,mBAAoB,CAAC,EACrB,UAAW,IACf,EAGAC,EAA+B,EAG/B,SAAeA,GAAiC,QAAAC,EAAA,sBAC5CC,EAAa,sCAAuC,OAAO,EACvD,OAAO,SAAS,SAAS,SAAS,mBAAmB,IACrD,MAAMC,EAA6B,GAEnC,OAAO,SAAS,SAAS,SAAS,eAAe,IACjDD,EACI,2DACA,QACJ,EACA,MAAME,EAAiB,GAEvB,OAAO,SAAS,SAAS,SAAS,qBAAqB,IACvDF,EACI,gEACA,QACJ,EACA,MAAME,EAAiB,GAI3B,OAAO,iBAAiB,QAASC,EAAkB,CACvD,GAEA,SAAsBF,GAA+B,QAAAF,EAAA,sBACjDC,EAAa,sCAAuC,OAAO,EAC3D,GAAI,CACA,MAAMI,EAAmB,CAC7B,OAASC,EAAP,CACEL,EAAa,gCAAiC,MAAOK,CAAU,CACnE,CACA,GAAI,CACA,MAAMC,EAAiB,CAC3B,OAASD,EAAP,CACEL,EAAa,8BAA+B,MAAOK,CAAU,CACjE,CACA,GAAI,CAEA,MAAME,EAAkB,CAC5B,OAASF,EAAP,CACEL,EAAa,+BAAgC,MAAOK,CAAU,CAClE,CACA,GAAI,CACA,MAAMG,EAAe,CACzB,OAASH,EAAP,CACEL,EAAa,4BAA6B,MAAOK,CAAU,CAC/D,CACA,GAAI,CACA,MAAMI,EAAgB,CAC1B,OAASJ,EAAP,CACEL,EAAa,6BAA8B,MAAOK,CAAU,CAChE,CACJ,GAEA,SAASK,GACLC,EACwB,CAExB,IADAX,EAAa,6BAA8B,SAAUW,CAAsB,EACpEA,GAAS,CACZ,GACIA,aAAmB,mBACnBA,EAAQ,aAAa,MAAM,EAE3B,OAAOA,EAEXA,EAAWA,EAAwB,cAEvC,OAAO,IACX,CAEA,SAASR,GAAmBE,EAAe,CACvC,IAAMO,EAASP,EAAE,OACXQ,EAASH,GAAqBE,CAAM,EAEpCE,EAAgB,oBAChBC,EAAqB,+BACrBC,EAAqB,sBAE3BhB,EAAa,mCAAmCa,GAAA,YAAAA,EAAQ,OAAQ,QAAQ,EAExE,IAAMI,EAAc,OAAO,SAAS,SACpC,WAAW,IAAYlB,EAAA,sBACnB,IAAMmB,EAAU,OAAO,SAAS,SAE5BD,IAAgBC,GAAW,OAAO,SAAS,OAI3CL,GAAA,MAAAA,EAAQ,KAAK,SAASC,IACtB,MAAMb,EAA6B,EACnCD,EACI,kDACA,QACJ,GAEO,OAAO,SAAS,SAAS,SAASe,CAAkB,GAC3Df,EACI,wDACA,QACJ,EACA,MAAME,EAAiB,GAIvBe,EAAY,SAASD,CAAkB,GACvC,OAAO,SAAS,SAAS,SAASA,CAAkB,IAEpDhB,EACI,wDACA,QACJ,EACA,MAAME,EAAiB,GAE3BF,EAAa,4BAA6B,QAAQ,EAClD,MAAMmB,EAAuB,EACjC,GAAG,GAAG,CACV",
  "names": ["typescript_exports", "__export", "addAddressButtons", "addContactSearchBox", "addTagElements", "appendTagLink", "appended", "checkNewTagAlert", "colorConsole", "constants_exports", "getAddressDivs", "processContactDivs", "runContactPageCustomizations", "startProspectCueCustomizations", "changeFontAwesomeIcons", "wait_elements_exports", "getAddressDivs", "labels", "_a", "addressDivChildren", "label", "colorConsole", "addressDivs", "appended", "logString", "color", "object", "colorMap", "wait_elements_exports", "__export", "waitForElement", "waitForManyElements", "waitForTextContent", "waitForElement", "props", "elementName", "selector", "colorConsole", "resolve", "reject", "element", "observer", "mutations", "mutation", "node", "waitForManyElements", "selectorAll", "numElements", "textContent", "elements", "waitForTextContent", "i", "addAddressButtons", "__async", "labels", "waitForManyElements", "addressDivs", "getAddressDivs", "colorConsole", "insertMapButtons", "_a", "_b", "_c", "_d", "_e", "_f", "_g", "_h", "newDiv", "streetLabel", "addressParams", "zillowParams", "val", "googleButton", "zillowButton", "addSectionToggle", "checkbox", "label", "toggleSections", "toggleDiv", "parentNode", "waitForElement", "e", "trigger", "appended", "constants_exports", "__export", "ACTIONS_DIVS_SELECTOR", "CONTACT_DIVS_SELECTOR", "CONTACT_SECTION_LABELS_SELECTOR", "Dialog", "settings", "__publicField", "__spreadValues", "formData", "object", "value", "key", "_a", "el", "len", "index", "dialog", "open", "resolve", "message", "template", "addTagElements", "__async", "colorConsole", "appended", "actionsSection", "waitForManyElements", "ACTIONS_DIVS_SELECTOR", "tagsSection", "i", "node", "heading", "newTagDiv", "appendTagLink", "checkNewTagAlert", "lastChild", "tagContainer", "tagLink", "e", "addNewTagSection", "waitForElement", "attachTagAlert", "addNewSection", "addNew", "addNewTagDiv", "tagAddClick", "_a", "target", "tagText", "dialog", "Dialog", "confirm", "processContactDivs", "__async", "contactDivs", "waitForManyElements", "CONTACT_DIVS_SELECTOR", "actionsSectionDivs", "ACTIONS_DIVS_SELECTOR", "CLOSED_PATH", "contactDiv", "contactDivTrigger", "path", "appended", "colorConsole", "e", "action", "actionTrigger", "addContactSearchBox", "__async", "parentNode", "waitForElement", "searchBox", "e", "_a", "searchValue", "contactDivs", "waitForManyElements", "CONTACT_DIVS_SELECTOR", "div", "attachSaveAlert", "__async", "formFooter", "waitForElement", "ahref", "handleSaveAlert", "getNumChanges", "targetDiv", "changesText", "match", "e", "numChanges", "target", "dialog", "Dialog", "confirm", "colorConsole", "changeFontAwesomeIcons", "__async", "waitForManyElements", "icon", "appended", "startProspectCueCustomizations", "__async", "colorConsole", "runContactPageCustomizations", "checkNewTagAlert", "handleWindowClicks", "processContactDivs", "e", "addSectionToggle", "addAddressButtons", "addTagElements", "attachSaveAlert", "findAncestorWithHref", "element", "target", "anchor", "CONTACTS_PATH", "CONVERSATIONS_PATH", "OPPORTUNITIES_PATH", "currentPath", "newPath", "changeFontAwesomeIcons"]
}
